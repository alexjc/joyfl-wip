## Copyright © 2025, Alex J. Champandard.  Licensed under AGPLv3; see LICENSE! ⚘
#
# joyfl — A minimal but elegant dialect of Joy, functional / concatenative stack language.
#

MODULE stdlib

PUBLIC

# ─────────────────────────────────────────────────────────────────────────────────────────────
# Basic Operations

    pred            ==  1 - ;
    --              ==  1 - ;
    succ            ==  1 + ;
    ++              ==  1 + ;

    str-swoncat     ==  swap str-concat ;


# ─────────────────────────────────────────────────────────────────────────────────────────────
# Stack Manipulation

    popd            ==  [pop] :dip ;
    swapd           ==  [swap] :dip ;

    rollup          ==  swap [swap] :dip ;
    rolldown        ==  [swap] :dip swap ;


# ─────────────────────────────────────────────────────────────────────────────────────────────
# Data Structures

    unit            ==  [] cons ;
    pair            ==  [] cons cons ;
    unpair          ==  uncons uncons pop ;

    swons           ==  swap cons ;
    unswons         ==  uncons swap ;
    swoncat         ==  swap concat ;
    swappend        ==  swap append ;


# ─────────────────────────────────────────────────────────────────────────────────────────────
# Function Calling

    x               ==  dup i ;
    y               ==  [dup cons] swap concat dup cons i ;

    dupd            ==  [dup] :dip ;

   (*  `dipd` — executes a quotation with the top two stack items saved and restored later.
    *   EXAMPLE:    1 2 3 [10 +] dipd rolldown 11 equal? .
    *   NOTE:       This version is intentionally cons free, alternative is [dip] cons dip.
    *)
    dipd            ==  swap [dip] :dip ;
    over            ==  dupd swap ;

    app1            ==  i ; 
    app2            ==  dup [dip] :dip i ;


# ─────────────────────────────────────────────────────────────────────────────────────────────
# Control Flow

   (*  `choice` — selects one of the two top stack items based on a boolean flag.
    *
    *   EXAMPLE:    true 'first 'second choice 'first equal? .
    *   NOTE:       This implementation makes a list and indexes it with bool as int.
    *)
    choice          :   (flag  x y         -- result)
                    #    false x y choice  →  y
                    #    true  x y choice  →  x
                    ==  swap pair index ;

   (*  `branch` — selects and executes one of two quotations based on a boolean.
    *
    *   EXAMPLE:    5 true [1 +] [1 -] branch put! .
    *   NOTE:       The flag is consumed, after which teh quatation is inlined with `i`.
    *)
    branch          :   (flag  [then] [else]         -- )
                    #    false [then] [else] branch  →  else
                    #    true  [then] [else] branch  →  then
                    ==  choice i ;

   (*  `nullary` — executes a quotation without affecting the stack, leaving only its result.
    *
    *   EXAMPLE:    10 5 [>] nullary assert! 5 equal? .
    *   NOTE:       The quotation can consume stack items but they are all restored afterward.
    *)
    nullary         ==  stack swap dip rest cons unstack ;

   (*  `_stack-and-keep-one` — (private) captures current stack state as a list while preserving input list.
    *
    *   EXAMPLE:    10 20 [5] _stack-and-keep-one → [20 10] [5]
    *   NOTE:       Solves the problem of comparing stack state before/after execution.
    *               After a quotation runs, we need to distinguish new results from preserved items.
    *               This captures the full stack snapshot while keeping the preserved list for comparison.
    *)
    _stack-and-keep-one : ( [preserved] -- [stack] [preserved] )
                        ==  dup                     # duplicate the preserved list for later use
                            [pop stack] dip ;       # capture entire stack while keeping preserved list
    
   (*  `_separate-results` — (private) separates quotation results from preserved stack items.
    *
    *   EXAMPLE:    After running a quotation: 1 2 99 [2 1] _separate-results → [99] [2 1]
    *   NOTE:       Solves the problem of stack preservation with variable-result quotations.
    *               Classic stack combinators assume fixed results, but real quotations may produce
    *               0, 1, or many results. This compares the current stack state (which contains
    *               both results and preserved items) against the preserved list baseline to compute
    *               how many results were produced, then extracts just those results.
    *)
    _separate-results : ( [results] [preserved] -- [results] [preserved] )
                      ==  dup size [swap] dip   # compute number of preserved items
                          over size swap -      # calculate result count = total - preserved
                          take                  # extract just the result items
                          swap ;                # reorder to [results] [preserved]

   (*  `unary` — executes a quotation with one argument, preserving the rest of the stack.
    *
    *   EXAMPLE:    1 2 3 [dup *] unary stack [9 2 1] equal? .
    *   NOTE:       Correctly handles quotations producing any number of results (0, 1, or many).
    *               Uses _separate-results helper to separate results from preserved stack items.
    *)
    
    unary           : ( x [P] -- R )
                    ==  stack rest rest               # save preserved items (excluding arg and quotation)
                        [i] dip                       # run quotation on argument, keep preserved list safe
                        _stack-and-keep-one           # get snapshot of all stack items
                        _separate-results             # separate quotation results from preserved items
                        concat                        # merge preserved and results into single list
                        unstack ;                     # restore all items to stack in correct order

   (*  `ifte` — if/then/else combinator for conditional execution.
    *
    *   EXAMPLE:    10 [5 >] [99 +] [99 -] ifte put! .
    *   NOTE:       Test is executed in nullary context, i.e. no stack effect.
    *)
    ifte            :   (x [test] [then] [else]       -- )
                    #    x [test] [then] [else] ifte  →  then-result or else-result
                    ==  [nullary] dipd :branch ;

   (*  `loop` — executes program repeatedly while flag is true.
    *
    *   EXAMPLE:    3 true [dup put! 1 - dup 0 >] loop .
    *   NOTE:       The looped program body is usually expected to produce the flag for the
    *               next iteration, though it can be prepared on the stack too.
    *)
    loop            :   (flag  [program]    -- )
                    #    true  [prog] loop  →  prog [prog] loop
                    #    false [prog] loop  →  ∅
                    ==  swap
                        [dup dip loop]
                        [pop]
                        :branch ;

   (*  `branch-cons` — conditionally cons an item onto one of two lists based on a flag.
    *)
    branch-cons     ==  [swap cons] [swapd swap cons swap] :branch;

   (*  `branch-append` — conditionally append an item to one of two lists based on a flag.
    *)
    branch-append   ==  [swap append] [swapd swap append swap] :branch;


# ─────────────────────────────────────────────────────────────────────────────────────────────
# Recursion

   (*  `while` — executes program repeatedly as long as condition is true.
    *
    *   EXAMPLE:    0 [dup 3 <] [dup put! 1 +] while 3 equal? .
    *   NOTE:       Unlike loop, condition and body are separate quotations evaluated on each iteration.
    *)
    while           ==  [dup dip swap] :dip swap                        # execute a copy of the condition
                        [dup [dip] :dip while]                              # execute the program and recurse
                        [pop pop]                                           # cleanup the stack once done
                        :branch ;                                           # check condition flag, pick right option

   (*  `cons4` — cons four items onto a list.
    *
    *   EXAMPLE:    1 2 3 4 [] cons4 [1 2 3 4] equal? .
    *   NOTE:       Helper combinator for building linrec's parameter structure.
    *)
    cons4           ==  cons cons cons cons ;

   (*  `linrec` — linear recursion combinator with four quotations.
    *
    *   EXAMPLE:    5 [0 =] [pop 1] [dup 1 -] [*] linrec 120 equal? .
    *   NOTE:       Pattern: [if] [then] [rec1] [rec2] linrec. Executes rec1 before recursion, rec2 after.
    *)
    linrec          ==  [linrec] cons4
                        dup
                        uncons swapd
                        uncons swapd
                        uncons [swap concat] :dip
                        uncons pop concat
                        :ifte ;

   (*  `tailrec` — tail recursion combinator with three quotations.
    *
    *   EXAMPLE:    5 0 [0 =] [pop] [dup 1 - swap 1 + swap] tailrec 5 equal? .
    *   NOTE:       Pattern: [if] [then] [rec] tailrec. Equivalent to [] linrec, no post-recursion operation.
    *)
    tailrec         ==  [] :linrec ;


# ─────────────────────────────────────────────────────────────────────────────────────────────
# Algorithms

   (*  `cond` — multi-way conditional selecting first matching case from list of [predicate body] pairs.
    *
    *   EXAMPLE:    5 [[[pop true] [999]] [[pop false] [42]]] cond 999 equal? .
    *   NOTE:       Each predicate receives the value and must return boolean; body executes when true.
    *)
    cond            ==  [ small? ]                                      # terminate recursion when single item list present
                        [ i ]                                           # if so, then we just execute it to unquote
                        [   dup first                                   # copy the cases, extract the first
                            dup first i                                 # copy first case, execute the predicate
                            [ rest swap pop ]                           #   success: from this case, extract body, remove original list
                            [ rest ]                                    #   failure: discard case from stack, remove it from list too
                            :branch                                     # decide which branch to take based on predicate result
                        ]
                        :tailrec ;

   (*  `foldl` — left fold reducing a list to single value using binary operation and initial accumulator.
    *
    *   EXAMPLE:    [1 2 3 4] 0 [+] foldl 10 equal? .
    *   NOTE:       Processes list left-to-right, passing accumulator and each element to the quotation.
    *)
    foldl           ==  swapd                                           # get the ACCUMULATOR, VALUES in order on the stack
                        [dup first swapd] swoncat [swap rest] concat    # assemble a dynamic list of instructions for each step
                        [null?] swap [pop] swap                         # reorder parameters for tailrec's benefit
                        :tailrec ;

   (*  `map` — applies quotation to each element of list, collecting results in new list.
    *
    *   EXAMPLE:    [1 2 3] [dup *] map [1 4 9] equal? .
    *   NOTE:       Preserves list order, quotation executed once per element with results accumulated.
    *)
    map             ==  [] rollup                                       # make a new ACCUMULATOR, and order it before VALUES
                        [dup first] swoncat                             # assemble a dynamic list of instructions for each step
                        [swap [swappend] :dip rest] concat              # -> [dup first PREDICATES swap [swappend] dip rest]
                        [null?] swap [pop] swap                         # reorder parameters based on tailrec's specification
                        :tailrec ;                                      # recurse and discard empty list

   (*  `split` — partitions list into two lists based on predicate, true matches first, false matches second.
    *
    *   EXAMPLE:    [1 2 3 4 5] [3 <] split pair [[1 2] [3 4 5]] equal? .
    *   NOTE:       Maintains relative order within each partition, processes entire input list.
    *)
    split           ==  [[] []] :dipd
                        [dup first dup] swoncat [rolldown [branch-append] :dip rest] concat
                        [null?] swap [pop swap] swap
                        :tailrec ;

   (*  `from-to` — generates list of integers from start to end with custom list builder quotation.
    *
    *   EXAMPLE:    1 3 [] from-to [1 2 3] equal? .
    *   NOTE:       Quotation parameter controls list construction method, typically [] or [cons].
    *)
    from-to         ==  [] cons  [pop pop] swoncat [>] swap [ [dup succ] dip ] [cons] linrec ;

   (*  `from-to-list` — generates list of integers from start to end inclusive.
    *
    *   EXAMPLE:    1 5 from-to-list [1 2 3 4 5] equal? .
    *   NOTE:       Convenience function using from-to with empty list builder.
    *)
    from-to-list    ==  [] from-to ;

END.
